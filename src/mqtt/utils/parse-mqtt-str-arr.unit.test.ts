import { muteConsole } from '../../common/db/testing'
import { parseMqttStrArr } from './parse-mqtt-str-arr'

beforeAll(() => {
  muteConsole()
})

describe('parseMqttStrArr function', () => {
  test('should return an empty array if str is null', () => {
    const arr = parseMqttStrArr(null)
    expect(Array.isArray(arr)).toBeTruthy()
    expect(arr.length).toBe(0)
  })
  test('should return an empty array if str is undefined', () => {
    const arr = parseMqttStrArr(null)
    expect(Array.isArray(arr)).toBeTruthy()
    expect(arr.length).toBe(0)
  })
  test('should return an empty array if str is empty', () => {
    const arr = parseMqttStrArr('')
    expect(Array.isArray(arr)).toBeTruthy()
    expect(arr.length).toBe(0)
  })
  test('should return correct array if str does not have any delimiters', () => {
    const arr = parseMqttStrArr('asd')
    expect(Array.isArray(arr)).toBeTruthy()
    expect(arr.length).toBe(1)
    expect(arr[0].length).toBe(1)
    expect(arr[0][0]).toBe('asd')
  })
  test('should return correct array if str has a single high level delimiter but element is single', () => {
    const arr = parseMqttStrArr('asd|')
    expect(Array.isArray(arr)).toBeTruthy()
    expect(arr.length).toBe(2)
    expect(arr[0].length).toBe(1)
    expect(arr[0][0]).toBe('asd')
    expect(arr[1].length).toBe(1)
    expect(arr[1][0]).toBe('')
  })
  test('should return correct array if str has two high level delimiters', () => {
    const arr = parseMqttStrArr('foo|bar')
    expect(Array.isArray(arr)).toBeTruthy()
    expect(arr.length).toBe(2)
    expect(arr[0].length).toBe(1)
    expect(arr[0][0]).toBe('foo')
    expect(arr[1].length).toBe(1)
    expect(arr[1][0]).toBe('bar')
  })
  test('should return correct array if str has three high level delimiters', () => {
    const arr = parseMqttStrArr('foo|bar|baz')
    expect(Array.isArray(arr)).toBeTruthy()
    expect(arr.length).toBe(3)
    expect(arr[0].length).toBe(1)
    expect(arr[0][0]).toBe('foo')
    expect(arr[1].length).toBe(1)
    expect(arr[1][0]).toBe('bar')
    expect(arr[2].length).toBe(1)
    expect(arr[2][0]).toBe('baz')
  })
  test('should return correct array for a single nested item', () => {
    const arr = parseMqttStrArr('foo*1*2*3')
    expect(Array.isArray(arr)).toBeTruthy()
    expect(arr.length).toBe(1)
    expect(arr[0].length).toBe(4)
    expect(arr[0][0]).toBe('foo')
    expect(arr[0][1]).toBe('1')
    expect(arr[0][2]).toBe('2')
    expect(arr[0][3]).toBe('3')
  })
  test('should return correct array for two nested items', () => {
    const arr = parseMqttStrArr('foo*1*2*3|bar*4*5*6')
    expect(Array.isArray(arr)).toBeTruthy()
    expect(arr.length).toBe(2)
    expect(arr[0].length).toBe(4)
    expect(arr[0][0]).toBe('foo')
    expect(arr[0][1]).toBe('1')
    expect(arr[0][2]).toBe('2')
    expect(arr[0][3]).toBe('3')
    expect(arr[1].length).toBe(4)
    expect(arr[1][0]).toBe('bar')
    expect(arr[1][1]).toBe('4')
    expect(arr[1][2]).toBe('5')
    expect(arr[1][3]).toBe('6')
  })
  test('should return correct array for two nested items with non-standard delimiters', () => {
    const arr = parseMqttStrArr('foo-1-2-3=bar-4-5-6', '=', '-')
    expect(Array.isArray(arr)).toBeTruthy()
    expect(arr.length).toBe(2)
    expect(arr[0].length).toBe(4)
    expect(arr[0][0]).toBe('foo')
    expect(arr[0][1]).toBe('1')
    expect(arr[0][2]).toBe('2')
    expect(arr[0][3]).toBe('3')
    expect(arr[1].length).toBe(4)
    expect(arr[1][0]).toBe('bar')
    expect(arr[1][1]).toBe('4')
    expect(arr[1][2]).toBe('5')
    expect(arr[1][3]).toBe('6')
  })
  test('should return correct array for real mqtt example', () => {
    const arr = parseMqttStrArr('sent*2*285384*1673027801900*1673027984198|queued*17*1646647|meta*56*28233|skipped*2*279592|stashed*0*0|archived*35*5015552|vault*0*0')
    expect(Array.isArray(arr)).toBeTruthy()
    expect(arr.length).toBe(7)
    const sent = arr[0]
    const queued = arr[1]
    const meta = arr[2]
    const skipped = arr[3]
    const stashed = arr[4]
    const archived = arr[5]
    const vault = arr[6]
    expect(sent.length).toBe(5)
    expect(sent[0]).toBe('sent')
    expect(sent[1]).toBe('2')
    expect(sent[2]).toBe('285384')
    expect(sent[3]).toBe('1673027801900')
    expect(sent[4]).toBe('1673027984198')
    expect(queued.length).toBe(3)
    expect(queued[0]).toBe('queued')
    expect(queued[1]).toBe('17')
    expect(queued[2]).toBe('1646647')
    expect(meta.length).toBe(3)
    expect(meta[0]).toBe('meta')
    expect(meta[1]).toBe('56')
    expect(meta[2]).toBe('28233')
    expect(skipped.length).toBe(3)
    expect(skipped[0]).toBe('skipped')
    expect(skipped[1]).toBe('2')
    expect(skipped[2]).toBe('279592')
    expect(stashed.length).toBe(3)
    expect(stashed[0]).toBe('stashed')
    expect(stashed[1]).toBe('0')
    expect(stashed[2]).toBe('0')
    expect(archived.length).toBe(3)
    expect(archived[0]).toBe('archived')
    expect(archived[1]).toBe('35')
    expect(archived[2]).toBe('5015552')
    expect(vault.length).toBe(3)
    expect(vault[0]).toBe('vault')
    expect(vault[1]).toBe('0')
    expect(vault[2]).toBe('0')
  })
})
